#!/usr/bin/env node
import { existsSync } from 'node:fs'
import { mkdir, readFile, writeFile } from 'node:fs/promises'
import path from 'node:path'

import { _extend } from '../utils'
import { includeTokenFilter } from '../filter/includeTokenFilter'

import type { TokenConfig } from './utils'
import {
  loadTokenConfig,
  sanitizeSubdir,
  slugifyAppearance,
  discoverAppearanceFiles,
  cleanBuildOutputsForSubdir,
} from './utils'

async function buildDynamicAppearances(cfg: TokenConfig) {
  const tokenConfig = cfg || {}

  const FIGMA_PROJECT_ID = (tokenConfig.figmaProjectFoundationId ?? '').trim()
  const FIGMA_PROJECT_DYNAMIC_ID = (
    tokenConfig.figmaProjectDynamicId ?? ''
  ).trim()
  if (!FIGMA_PROJECT_ID) {
    console.error(
      'Missing figmaProjectFoundationId. Set it in token-config.json (figmaProjectFoundationId).',
    )
    process.exit(1)
  }
  if (!FIGMA_PROJECT_DYNAMIC_ID) {
    console.error(
      'Missing figmaProjectDynamicId. Set it in token-config.json (figmaProjectDynamicId).',
    )
    process.exit(1)
  }

  const TOKEN_BASE = path.join('tokens', FIGMA_PROJECT_ID)
  const TOKENS_DYNAMIC_DIR = path.join('tokens', FIGMA_PROJECT_DYNAMIC_ID)
  const LIGHT_COLORS = path.join(TOKEN_BASE, 'Color Light.Mode 1.json')

  const SCHEME_TOKENS_PREFIX =
    tokenConfig.schemeTokensPrefix ?? 'ðŸŒ— Color Scheme'
  const LIGHT_SCHEME = path.join(
    TOKEN_BASE,
    `${SCHEME_TOKENS_PREFIX}.Light.json`,
  )
  // Appearance files reference families (e.g., Gray, Blue, Moss Green) that are defined in the scheme files,
  // which in turn reference the palette files. Include both light and dark scheme/palette to resolve refs.

  const COLOR_PREFIX = `${tokenConfig.variablePrefix ?? 'x'}-color`
  const BUILD_PATH = path.posix.join(
    tokenConfig.buildPath ?? 'color/',
    'dynamic/',
  ) // subfolder under build/css

  // Discover tokens: ðŸŽ¨ Appearance.*.json
  const appearanceFiles = await discoverAppearanceFiles(TOKENS_DYNAMIC_DIR)
  if (appearanceFiles.length === 0) {
    console.warn(
      `No appearance files found in ${TOKENS_DYNAMIC_DIR} (looking for 'ðŸŽ¨ Appearance.*.json').`,
    )
    return [] as string[]
  }

  // Build each appearance to CSS using style-dictionary via _extend
  const builtFiles: string[] = []
  for (const entry of appearanceFiles) {
    const rawName = entry.name
      .replace(/^ðŸŽ¨\s*Appearance\./, '')
      .replace(/\.json$/, '')
    const appearance = slugifyAppearance(rawName) // e.g., Neutral -> neutral

    const selector =
      appearance === 'neutral'
        ? `:root, [data-color-appearance="neutral"]`
        : `[data-color-appearance="${appearance}"]`

    const fileName = `semantic-${appearance}`

    const dict = _extend({
      source: [entry.abs],
      include: [LIGHT_SCHEME, LIGHT_COLORS],
      // Only output Appearance tokens; keep scheme/aliases available for references
      filter: (token: any) => includeTokenFilter(token, ['Appearance']),
      buildPath: BUILD_PATH,
      fileName,
      selector,
      prefix: COLOR_PREFIX,
      outputReferences: true,
    })

    await dict.buildAllPlatforms()
    // CSS platform from @equinor/eds-tokens-build emits "-verbose.css"
    // CSS files are emitted under build/css/<BUILD_PATH>
    const verbosePath = path.join(
      'build/css',
      BUILD_PATH,
      `${fileName}-verbose.css`,
    )
    builtFiles.push(verbosePath)
  }

  return builtFiles
}

async function combineDynamicCss(builtFiles: string[], outPath: string) {
  // Ensure output dir exists
  await mkdir(path.dirname(outPath), { recursive: true })

  // Place neutral first if present
  const neutralFirst = [
    // Ensure neutral is first, without relying on non-existent "dynamic" in file name
    ...builtFiles.filter((p) => /semantic-neutral-verbose\.css$/.test(p)),
    ...builtFiles.filter((p) => !/semantic-neutral-verbose\.css$/.test(p)),
  ]

  const parts: string[] = []
  for (const file of neutralFirst) {
    if (!existsSync(file)) continue
    const css = await readFile(file, 'utf8')
    parts.push(css.trim())
  }

  const banner = `/**\n * Do not edit directly, this file was auto-generated by scripts/build-semantic-dynamic-variables.ts.\n */`
  const combined = [banner, '', ...parts, ''].join('\n\n')
  await writeFile(outPath, combined, 'utf8')
  console.log(`Combined dynamic colors written to ${outPath}`)
}

async function main() {
  const args = new Set(process.argv.slice(2))
  const cfg = loadTokenConfig()

  const doClean = !args.has('--no-clean')
  const skipBuild = args.has('--skip-build')
  const skipCombine = args.has('--skip-combine')

  if (args.has('-h') || args.has('--help')) {
    console.log(
      `Usage: build-dynamic-variables [options]\n\n` +
        `Options:\n` +
        `  --no-clean       Do not clean build outputs before running\n` +
        `  --skip-build     Skip the token build step\n` +
        `  --skip-combine   Skip combining into variables.css\n` +
        `  -h, --help       Show this help`,
    )
    process.exit(0)
  }

  if (doClean) {
    const base = cfg.buildPath ?? 'color/'
    const sub = path.posix.join(base, 'dynamic/')
    await cleanBuildOutputsForSubdir(sub)
  }

  const built = skipBuild ? [] : await buildDynamicAppearances(cfg)

  if (!skipCombine) {
    const out = path.resolve(
      'build/css',
      sanitizeSubdir(path.posix.join(cfg.buildPath ?? 'color/', 'dynamic/')),
      'variables.css',
    )
    await combineDynamicCss(built, out)
  }
}

main().catch((err) => {
  console.error('[generate-dynamic-appearance] Failed:')
  console.error(err)
  process.exit(1)
})
