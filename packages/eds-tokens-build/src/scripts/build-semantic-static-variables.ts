import { readFile, writeFile, mkdir } from 'node:fs/promises'
import path from 'node:path'
import type { TransformedToken } from 'style-dictionary/types'
import { _extend } from '../utils'
import { includeTokenFilter } from '../filter/includeTokenFilter'

import type { TokenConfig } from './utils'
import {
  loadTokenConfig,
  sanitizeSubdir,
  extractRootInner,
  indentLines,
  cleanBuildOutputsForSubdir,
} from './utils'

async function buildColorsFromConfig(cfg: TokenConfig) {
  const tokenConfig = cfg || {}

  const FIGMA_PROJECT_ID = (tokenConfig.figmaProjectFoundationId ?? '').trim()
  if (!FIGMA_PROJECT_ID) {
    console.error(
      'Missing figmaProjectFoundationId. Set it in token-config.json (figmaProjectFoundationId).',
    )
    process.exit(1)
  }

  const FIGMA_STATIC_PROJECT_ID = (
    tokenConfig.figmaProjectStaticId ?? ''
  ).trim()
  if (!FIGMA_STATIC_PROJECT_ID) {
    console.error(
      'Missing figmaProjectStaticId. Set it in token-config.json (figmaProjectStaticId).',
    )
    process.exit(1)
  }

  const SCHEME_TOKENS_PREFIX =
    tokenConfig.schemeTokensPrefix ?? 'ðŸŒ— Color Scheme'
  const TOKEN_BASE = path.join('tokens', FIGMA_PROJECT_ID)
  const LIGHT_COLORS = path.join(TOKEN_BASE, 'Color Light.Mode 1.json')

  const LIGHT_SCHEME = path.join(
    TOKEN_BASE,
    `${SCHEME_TOKENS_PREFIX}.Light.json`,
  )

  const SEMANTIC_COLORS = path.join(
    'tokens',
    FIGMA_STATIC_PROJECT_ID,
    'Semantic.Mode 1.json',
  )
  const BUILD_PATH = path.posix.join(
    tokenConfig.buildPath ?? 'color/',
    'static/',
  ) // subfolder under build/css
  const PREFIX = tokenConfig.variablePrefix ?? 'x'
  const COLOR_PREFIX = PREFIX + '-color' // e.g. "x-color"

  // Build static semantic tokens with light theme values and CSS variable references
  const semanticColors = _extend({
    source: [SEMANTIC_COLORS],
    include: [LIGHT_COLORS, LIGHT_SCHEME], // use one scheme to resolve references
    filter: (token: TransformedToken) =>
      includeTokenFilter(token, ['Semantic']),
    buildPath: BUILD_PATH,
    prefix: COLOR_PREFIX,
    fileName: 'semantic',
    selector: ':root',
    outputReferences: true,
  })

  await semanticColors.buildAllPlatforms()

  // Build semantic color scheme tokens with resolved light/dark values
  const DARK_COLORS = path.join(TOKEN_BASE, 'Color Dark.Mode 1.json')
  const DARK_SCHEME = path.join(TOKEN_BASE, `${SCHEME_TOKENS_PREFIX}.Dark.json`)
  const SCHEME_BUILD_PATH = path.posix.join(
    tokenConfig.buildPath ?? 'color/',
    'color-scheme/',
  )

  const lightSemanticColors = _extend({
    source: [SEMANTIC_COLORS],
    include: [LIGHT_COLORS, LIGHT_SCHEME],
    filter: (token: TransformedToken) =>
      includeTokenFilter(token, ['Semantic']),
    buildPath: SCHEME_BUILD_PATH,
    fileName: 'light-semantic',
    selector: '[data-color-scheme="light"]',
    prefix: COLOR_PREFIX,
    outputReferences: false,
  })

  const darkSemanticColors = _extend({
    source: [SEMANTIC_COLORS],
    include: [DARK_COLORS, DARK_SCHEME],
    filter: (token: TransformedToken) =>
      includeTokenFilter(token, ['Semantic']),
    buildPath: SCHEME_BUILD_PATH,
    fileName: 'dark-semantic',
    selector: '[data-color-scheme="dark"]',
    prefix: COLOR_PREFIX,
    outputReferences: false,
  })

  await lightSemanticColors.buildAllPlatforms()
  await darkSemanticColors.buildAllPlatforms()
}

async function combineColorsFromConfig(cfg: TokenConfig) {
  const BUILD_PATH = path.posix.join(cfg.buildPath ?? 'color/', 'static/')
  const baseDir = path.resolve('build/css', sanitizeSubdir(BUILD_PATH))
  const semanticPath = path.join(baseDir, 'semantic-verbose.css')
  const outputFileName = 'variables.css'
  const outPath = path.join(baseDir, outputFileName)

  const semanticCss = await readFile(semanticPath, 'utf8')
  const semanticInner = extractRootInner(semanticCss)

  const banner = `/**\n * Do not edit directly, this file was auto-generated by scripts/build-static-variables.ts.\n * Note: color scheme variables have moved to color-scheme.css. Import both files.\n */`

  const mergedRoot = [':root {', indentLines(semanticInner), '}'].join('\n')

  const combined = [banner, '', mergedRoot, ''].join('\n')

  await mkdir(baseDir, { recursive: true })
  await writeFile(outPath, combined, 'utf8')
  console.log(`Combined colors written to ${outPath}`)
}

async function main() {
  const args = new Set(process.argv.slice(2))
  const cfg = loadTokenConfig()

  const doClean = !args.has('--no-clean')
  const skipBuild = args.has('--skip-build')
  const skipCombine = args.has('--skip-combine')

  if (args.has('-h') || args.has('--help')) {
    console.log(
      `Usage: build-variables [options]\n\n` +
        `Options:\n` +
        `  --no-clean       Do not clean build outputs before running\n` +
        `  --skip-build     Skip the token build step\n` +
        `  --skip-combine   Skip combining into variables.css\n` +
        `  -h, --help       Show this help`,
    )
    process.exit(0)
  }

  if (doClean) {
    const base = cfg.buildPath ?? 'color/'
    const sub = path.posix.join(base, 'static/')
    await cleanBuildOutputsForSubdir(sub)
  }
  if (!skipBuild) await buildColorsFromConfig(cfg)
  if (!skipCombine) await combineColorsFromConfig(cfg)
}

main().catch((err) => {
  console.error('[build-variables] Failed:')
  console.error(err)
  process.exit(1)
})
