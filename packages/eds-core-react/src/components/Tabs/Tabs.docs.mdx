import { Links } from './../../../.storybook/components'
import { Primary, Canvas, Meta, Controls } from '@storybook/blocks'
import * as ComponentStories from './Tabs.stories'

<Meta of={ComponentStories} />

# Tabs

Organise related content across different views to be quickly navigated.

<Links 
    ariaUrl="https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/"
    figmaUrl="https://www.figma.com/file/0bGXR2sCwMVSDNyyzu5BXrO5/UI%E2%80%94User-Interface?node-id=17417%3A0"
    documentationUrl="https://eds.equinor.com/0b0c666ab/p/50d3be-tabs/b/94939a"
    sourceUrl="https://github.com/equinor/design-system/blob/develop/packages/eds-core-react/src/components/Tabs/Tabs.tsx"
    npmUrl="https://www.npmjs.com/package/@equinor/eds-core-react"
/>

<Primary />
<Controls />

## Usage

Tabs allow for navigation between content that is related and has an equal hierarchy.

<ul>
    <li>Each tab's content should be noticeably different from the other.</li>
    <li>Tabs allow for information to be presented in a space-saving layout.</li>
    <li>Tab labels should provide clear and concise direction.</li>
</ul>

```tsx
import { Tabs } from '@equinor/eds-core-react'
import { useState } from 'react'

function TabsExample() {
  const [activeTab, setActiveTab] = useState(0)
  const handleChange = (index: number | string) => {
    setActiveTab(index)
  }
return (
  <Tabs activeTab={activeTab} onChange={handleChange}>
      <Tabs.List>
        <Tabs.Tab>One</Tabs.Tab>
        <Tabs.Tab>Two</Tabs.Tab>
      </Tabs.List>
      <Tabs.Panels>
        <Tabs.Panel>Panel one</Tabs.Panel>
        <Tabs.Panel>Panel two</Tabs.Panel>
      </Tabs.Panels>
  </Tabs>
  )
}

```

## Examples

### States

<Canvas of={ComponentStories.States} />

### Widths

Tab width can be decided by three factors:
<ol>
    <li>The width of the space available being equally divided by the number of tabs. This method is only to be used for four tabs or less.</li>
    <li>The width of the widest tab determining the width of all the tabs to provide visual balance. 
        This should be used with caution ensuring all tabs will be seen in smaller layouts.</li>
    <li>Each tab having its own minimum width to conserve space.</li>
</ol>

<Canvas of={ComponentStories.Widths} />

### With panels

To navigate using the keyboard use:
<ul>
    <li><code>TAB</code> to move from tab to tab panel.</li>
    <li><code>SHIFT + TAB</code> to go backwards.</li>
    <li><code>LEFT / RIGHT ARROW</code> to move from between tabs (active tab must be focused).</li>
</ul>

Focus outline is only visible when navigating using the keyboard.

The non-active `Tabs.Panels` are by default hidden with `display: none`, but can instead be conditionally rendered by adding the `conditionalRender` prop

<Canvas of={ComponentStories.WithPanels} />

### With third party routers
`Tabs.Tab` can be rendered as another component using the `as` prop.
```tsx
import { Tabs } from '@equinor/eds-core-react'
import { Link, Outlet } from "react-router-dom";

  <Tabs activeTab="/foo/bar">
  <Tabs.List>
      <Tabs.Tab as={Link} value="/foo/bar" to="/foo/bar">bar</Tabs.Tab>
      <Tabs.Tab as={Link} value="/foo/baz" to="/foo/baz">baz</Tabs.Tab>
  </Tabs.List>
  <Outlet />
  </Tabs>
```
Routes can of course be entered by other means than clicking tabs. Therefore, we can not reliably use `onChange` to send a new index to `activeTab`. Instead `activeTab` can take a string value that sets the correct active tab if it matches the `value` prop on a tab. In the below example we use `react-router-dom` and its provided functions to match the current path to the correct tab.
<Canvas of={ComponentStories.Router} />

### With search

<Canvas of={ComponentStories.WithSearch} />

### With input in panel

<Canvas of={ComponentStories.WithInputInPanel} />

### With styled component

Tabs with panels rendered from collection.

<Canvas of={ComponentStories.WithStyledComponent} />

### Overflow with next/previous buttons

Tabs uses css `scroll-snap`, so in a case where there is overflow and the user wants to add next/previous buttons for scrolling, 
they can use `element.scrollTo` some amount and then css will take care of alignment.

<Canvas of={ComponentStories.Overflow} />

### Overflow with default scrollbar

In the case of tabs overflowing, and where next/previous buttons are not desired, the `scrollable` prop adds `overflow-x: auto` to the tabs list. 
Tabs uses css `scroll-snap` which handles alignment and tabs snapping into place. 
Note that scrollbar had been disabled for touch devices since the tabs are swipeable.

<Canvas of={ComponentStories.OverflowScroll} />

### Overflow with customized scrollbar

The scrollbar styles for `Tabs.List` can be overwritten.

<Canvas of={ComponentStories.OverflowScrollStyled} />

