#!/usr/bin/env node

/**
 * Script to generate Code Connect entries for all icon components in a Figma file.
 *
 * Usage:
 *   node scripts/generate-icon-figma-connect.mjs --token <FIGMA_ACCESS_TOKEN>
 *
 * Or set environment variables:
 *   FIGMA_ACCESS_TOKEN=your_token
 *   node scripts/generate-icon-figma-connect.mjs
 *
 * The script will:
 * 1. Fetch all component sets (icons with variants) from the Figma file
 * 2. Fetch all standalone components (icons without variants) from the Figma file
 * 3. Generate Code Connect entries:
 *    - Component sets: with variant restriction for Density=Default
 *    - Standalone components: without variant restriction
 * 4. Write to packages/eds-core-react/src/figma/IconData.figma.tsx
 */

import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const FIGMA_API_BASE = 'https://api.figma.com/v1'
const FILE_KEY = 'BQjYMxdSdgRkdhKTDDU7L4KU'

/**
 * Convert Figma component name to icon name format
 * - Lowercase
 * - Spaces replaced with underscores
 */
function toIconName(name) {
  return name
    .toLowerCase()
    .replace(/\s+/g, '_')
    .replace(/-/g, '_')
    .replace(/[^a-z0-9_]/g, '')
}

/**
 * Fetch component sets from Figma file (icons with variants)
 */
async function fetchFigmaComponentSets(fileKey, token) {
  const url = `${FIGMA_API_BASE}/files/${fileKey}/component_sets`

  const response = await fetch(url, {
    headers: {
      'X-Figma-Token': token,
    },
  })

  if (!response.ok) {
    const errorText = await response.text()
    throw new Error(
      `Failed to fetch Figma component sets: ${response.status} ${response.statusText}\n${errorText}`,
    )
  }

  const data = await response.json()
  return data.meta.component_sets || []
}

/**
 * Fetch standalone components from Figma file (icons without variants)
 */
async function fetchFigmaComponents(fileKey, token) {
  const url = `${FIGMA_API_BASE}/files/${fileKey}/components`

  const response = await fetch(url, {
    headers: {
      'X-Figma-Token': token,
    },
  })

  if (!response.ok) {
    const errorText = await response.text()
    throw new Error(
      `Failed to fetch Figma components: ${response.status} ${response.statusText}\n${errorText}`,
    )
  }

  const data = await response.json()
  return data.meta.components || []
}

/**
 * Filter components/component sets
 */
function filterByName(items, filter) {
  if (!filter) return items
  return items.filter((item) =>
    item.name.toLowerCase().includes(filter.toLowerCase()),
  )
}

/**
 * Generate the Code Connect file content
 * - Component sets get variant restriction for Density=Default
 * - Standalone components don't have variant restriction
 */
function generateCodeConnectFile(componentSets, standaloneComponents, fileKey) {
  const baseUrl = `https://www.figma.com/design/${fileKey}`

  const imports = `import figma from '@figma/code-connect'

/**
 * Auto-generated Code Connect entries for icons.
 * Generated by scripts/generate-icon-figma-connect.mjs
 *
 * Each icon is connected to return its name as a string,
 * which can be used with figma.instance<string>() in parent components.
 */
`

  // Generate connections for component sets (with Density variant)
  const componentSetConnections = componentSets.map((componentSet) => {
    const iconName = toIconName(componentSet.name)
    const nodeId = componentSet.node_id.replace(':', '%3A')
    const url = `${baseUrl}?node-id=${nodeId}`

    return `figma.connect('${url}', {
  variant: { Density: 'Default' },
  example: () => '${iconName}',
})`
  })

  // Generate connections for standalone components (no variant)
  const standaloneConnections = standaloneComponents.map((component) => {
    const iconName = toIconName(component.name)
    const nodeId = component.node_id.replace(':', '%3A')
    const url = `${baseUrl}?node-id=${nodeId}`

    return `figma.connect('${url}', {
  example: () => '${iconName}',
})`
  })

  const allConnections = [
    ...componentSetConnections,
    ...standaloneConnections,
  ].join('\n\n')

  return `${imports}\n${allConnections}\n`
}

/**
 * Parse command line arguments
 */
function parseArgs() {
  const args = process.argv.slice(2)
  let token = process.env.FIGMA_ACCESS_TOKEN || ''
  let filter

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--token' && args[i + 1]) {
      token = args[i + 1]
      i++
    } else if (args[i] === '--filter' && args[i + 1]) {
      filter = args[i + 1]
      i++
    }
  }

  if (!token) {
    console.error(
      'Error: Figma access token is required. Use --token or set FIGMA_ACCESS_TOKEN env variable.',
    )
    console.error(
      'Generate a token at: https://www.figma.com/developers/api#access-tokens',
    )
    process.exit(1)
  }

  return { token, filter }
}

async function main() {
  const { token, filter } = parseArgs()
  const fileKey = FILE_KEY

  console.log(`Fetching icons from Figma file: ${fileKey}`)

  try {
    // Fetch both component sets and standalone components
    const [componentSets, allComponents] = await Promise.all([
      fetchFigmaComponentSets(fileKey, token),
      fetchFigmaComponents(fileKey, token),
    ])

    console.log(
      `Found ${componentSets.length} component sets (icons with variants)`,
    )
    console.log(`Found ${allComponents.length} total components`)

    // Get the node IDs of all component sets to filter them out from standalone components
    const componentSetNodeIds = new Set(componentSets.map((cs) => cs.node_id))

    // Standalone components are those that don't belong to a component set
    // A component belongs to a component set if:
    // 1. It has a component_set_id property, OR
    // 2. Its containing_frame.nodeId matches a component set
    const standaloneComponents = allComponents.filter((component) => {
      // If the component has a component_set_id, it's a variant
      if (component.component_set_id) {
        return false
      }

      // Check if this component's parent is a component set
      const containingFrameId = component.containing_frame?.nodeId
      if (containingFrameId && componentSetNodeIds.has(containingFrameId)) {
        return false // This is a variant inside a component set
      }

      // Also check if the component name contains "=" which indicates it's a variant
      // Variants typically have names like "Density=Default" or "Size=Large, State=Active"
      if (component.name.includes('=')) {
        return false
      }

      return true // This is a standalone component
    })

    console.log(
      `Found ${standaloneComponents.length} standalone components (icons without variants)`,
    )

    // Apply filter if provided
    const filteredComponentSets = filterByName(componentSets, filter)
    const filteredStandaloneComponents = filterByName(
      standaloneComponents,
      filter,
    )

    const totalIcons =
      filteredComponentSets.length + filteredStandaloneComponents.length

    if (totalIcons === 0) {
      console.warn('No icons found. Check your filter criteria.')
      return
    }

    // Generate the file content
    const content = generateCodeConnectFile(
      filteredComponentSets,
      filteredStandaloneComponents,
      fileKey,
    )

    // Write to output file
    const outputPath = path.join(
      __dirname,
      '../packages/eds-core-react/src/figma/IconData.figma.tsx',
    )

    fs.mkdirSync(path.dirname(outputPath), { recursive: true })
    fs.writeFileSync(outputPath, content, 'utf-8')

    console.log(`\nGenerated ${outputPath}`)
    console.log(`Total icons: ${totalIcons}`)
    console.log(
      `  - Component sets (with Density variant): ${filteredComponentSets.length}`,
    )
    console.log(
      `  - Standalone components: ${filteredStandaloneComponents.length}`,
    )

    // Print first few for verification
    console.log('\nFirst 5 component sets:')
    filteredComponentSets.slice(0, 5).forEach((c) => {
      console.log(`  - ${c.name} -> ${toIconName(c.name)}`)
    })

    console.log('\nFirst 5 standalone components:')
    filteredStandaloneComponents.slice(0, 5).forEach((c) => {
      console.log(`  - ${c.name} -> ${toIconName(c.name)}`)
    })
  } catch (error) {
    console.error('Error:', error.message || error)
    process.exit(1)
  }
}

main()
